// COIN FLIPPING PROTOCOL FOR POLYNOMIAL RANDOMIZED CONSENSUS [AH90] 
// gxn/dxp 20/11/00

mdp

// constants
const int N=2;
const int K;
const int range = 2*(K+1)*N;
const int counter_init = (K+1)*N;
const int left = N;
const int right = 2*(K+1)*N - N;

// shared coin
// init value and bound was modified by hand (was constant range/counter_init)
global counter : [0..((2 * (K + 1)) * 2)] init (K+1)*2;

module process1
	
	// program counter
	pc1 : [0..3];
	// 0 - flip
	// 1 - write 
	// 2 - check
	// 3 - finished
	
	// local coin
	coin1 : [0..1];

	[done] (pc1=3)  -> 1: (pc1'=3);
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & (((counter + 1) > 2) & ((counter + 1) < (((2 * (K + 1)) * 2) - 2)))) & ((counter > 0) & ((counter - 1) <= 2))) -> 1/2: (pc1'=0) & (coin1'=0) & (counter'=(counter + 1)) + 1/2: (pc1'=3) & (coin1'=0) & (counter'=(counter - 1));
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & (((counter + 1) > 2) & ((counter + 1) < (((2 * (K + 1)) * 2) - 2)))) & ((counter > 0) & (((counter - 1) > 2) & ((counter - 1) < (((2 * (K + 1)) * 2) - 2))))) -> 1/2: (pc1'=0) & (coin1'=0) & (counter'=(counter + 1)) + 1/2: (pc1'=0) & (coin1'=0) & (counter'=(counter - 1));
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & ((counter + 1) >= (((2 * (K + 1)) * 2) - 2))) & ((counter > 0) & ((counter - 1) <= 2))) -> 1/2: (pc1'=3) & (coin1'=1) & (counter'=(counter + 1)) + 1/2: (pc1'=3) & (coin1'=0) & (counter'=(counter - 1));
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & ((counter + 1) >= (((2 * (K + 1)) * 2) - 2))) & ((counter > 0) & ((counter - 1) >= (((2 * (K + 1)) * 2) - 2)))) -> 1/2: (pc1'=3) & (coin1'=1) & (counter'=(counter + 1)) + 1/2: (pc1'=3) & (coin1'=1) & (counter'=(counter - 1));
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & ((counter + 1) >= (((2 * (K + 1)) * 2) - 2))) & ((counter > 0) & (((counter - 1) > 2) & ((counter - 1) < (((2 * (K + 1)) * 2) - 2))))) -> 1/2: (pc1'=3) & (coin1'=1) & (counter'=(counter + 1)) + 1/2: (pc1'=0) & (coin1'=0) & (counter'=(counter - 1));
	[] (pc1=0) &  (((counter < ((2 * (K + 1)) * 2)) & ((counter + 1) <= 2)) & ((counter > 0) & ((counter - 1) <= 2))) -> 1/2: (pc1'=3) & (coin1'=0) & (counter'=(counter + 1)) + 1/2: (pc1'=3) & (coin1'=0) & (counter'=(counter - 1));


endmodule

// construct remaining processes through renaming
module process2 = process1[pc1=pc2,coin1=coin2] endmodule

// labels
//label "finished" = pc1=3 & pc2=3 ;
//label "all_coins_equal_0" = coin1=0 & coin2=0 ;
//label "all_coins_equal_1" = coin1=1 & coin2=1 ;
//label "agree" = coin1=coin2 ;

// rewards
rewards "steps"
	true : 1;
endrewards

